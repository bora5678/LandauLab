import pyvisa



class Keysight33500B():
    """Class to define functions and values used for the control of Keysight 33500b"""

    def __init__(self, dev, stat, msg):
        self.dev = dev
        self.stat = stat
        self.msg = msg

        rm = pyvisa.ResourceManager('@py')
        devices = rm.list_resources('?*')
        # Find the first device with 'TCPIP' in its name
        tcpip_devices = [dev for dev in devices if 'TCPIP' in dev.upper()]
        if not tcpip_devices:
            raise Exception("No TCPIP device found.")
        my_device = tcpip_devices[0]
        instrument = rm.open_resource(my_device)
        print(f"Connected to: {instrument.query('*IDN?')}")
        instrument.write('DISP On')
        self.dev = instrument
    
    def errorcheck(self):
        """Function to check for errors in the device"""
        status = self.dev.query('*STB?').strip()
        self.stat = status[1] if len(status) > 1 else status
        if self.stat != '0':
            self.msg = self.dev.query(':SYSTem:ERRor?').strip()
        else:
            self.msg = None

    def disconnect(self):
        """Function to disconnect the device"""
        self.dev.close()
        print("Device disconnected.")

    def outp_on(self, channel):
        """Function to turn on the output of the device"""
        self.dev.write(f'OUTP{channel}: ON')
        self.errorcheck()
        if self.msg:
            print(f"Error: {self.msg}")
        else:
            print(f"Output {channel} turned on.")
    
    def outp_off(self, channel):
        """Function to turn off the output of the device"""
        self.dev.write(f'OUTPut{channel}: OFF')
        self.errorcheck()
        if self.msg:
            print(f"Error: {self.msg}")
        else:
            print(f"Output {channel} turned off.")

    def selectSine(self, unit, amp, freq, offset):
        """Function to select the sine wave"""
        self.dev.write(f'VOLT:UNIT {unit}')
        self.dev.write('SOURce1:FUNCtion SINusoid')
        self.dev.write(f'SOURce1:VOLTage {amp}')
        self.dev.write(f'SOURce1:FREQuency {freq}')
        self.dev.write(f'SOURce1:VOLTage:OFFSet {offset}')

    def selectDC(self, offset):
        """Function to select the DC wave"""
        self.dev.write('SOURce1:FUNCtion DC')
        self.dev.write(f'SOURce1:VOLTage:OFFSet {offset}')

    def selectSquare(self, unit, amp, freq, offset, dutycycle):
        """Function to select the square wave"""
        self.dev.write(f'VOLT:UNIT {unit}')
        self.dev.write(f'SOURce1:VOLTage {amp}')
        self.dev.write('SOURce1:FUNCtion SQUare')
        self.dev.write(f'SOURce1:FREQuency {freq}')
        self.dev.write(f'SOURce1:VOLTage:OFFSet {offset}')
        self.dev.write(f'SOURce1:FUNCtion:SQUare:DUTYcycle {dutycycle}')

    def selectNoise(self, unit, amplitude, offset, bandwidth):
        """Function to select the noise wave"""
        self.dev.write(f'VOLT:UNIT {unit}')
        self.dev.write('SOURce1:FUNCtion NOISe')
        self.dev.write(f'SOURce1:VOLTage {amplitude}')
        self.dev.write(f'SOURce1:VOLTage:OFFset {offset}')
        self.dev.write(f'SOURce1:FUNCtion:NOISe:BANDwidth {bandwidth}')

    def burst_mode(self, state, ncycle):
        """Function to set the burst mode state ON|OFF"""
        self.dev.write('SOUR:BURS:MODE TRIG')
        self.dev.write(f'SOUR1:BURS:STAT {state}')
        self.dev.write(f'BURS:NCYC {ncycle}')

    def set_trigger(self, source):
        """Function to set the trigger"""
        #{IMMediate|EXTernal|TIMer|BUS}
        self.dev.write(f'TRIG:SOUR {source}')
        self.dev.write('BURS:STAT ON')
        self.dev.write('BURS:MODE TRIG')
        self.dev.write('OUTP:TRIG ON')


    def sendMANTrig(self):
        """Function to send the manual trigger"""
        self.dev.write(':TRIG')